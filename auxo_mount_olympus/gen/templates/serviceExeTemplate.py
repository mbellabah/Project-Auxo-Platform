################################################################################
## Code generated by Auxo Mount Olympus v. {{ package.template_version }}
##
## Service Name: {{ package.service_name }}
## Created by: {{ package.author }} 
## Date: {{ package.created }}
## Description: {{ package.description }}
##
## Read through the comments, make changes/decisions at the FIXMEs
################################################################################

import time 
import json 

from auxo_olympus.lib.entities.mdwrkapi import MajorDomoWorker
from auxo_olympus.lib.services.service_exe import ServiceExeBase


class ServiceExe{{ package.service_name_compressed }}(ServiceExeBase):
    def __init__(self, *args):
        super().__init__(*args)
        self.service_name = "{{ package.service_name_compressed }}".lower()
        self.name = f'{self.service_name}-Thread'
        
        # Uncomment the line below if the worker in this service requires inputs (provided by self.inputs)
        # assert self.inputs, "Need to provide kwargs (command line) when initing the service"      # FIXME 

    # Override process
    def process(self, *args, **kwargs) -> dict:
        try:
            request: dict = json.loads(args[0])     # the client's request 
            worker: MajorDomoWorker = args[1]       # the worker attached to this serviceExe (passed by the agent)
        except IndexError:
            raise IndexError('Error: worker object has not been supplied:')

        self.worker = worker
        MULTIWORKER = request.get("multiple_bool", False)      # NOTE: when defining the "client-side" launch file for this service, be sure to state whether this service needs multiple *interacting* workers

        # NOTE: if worker needs to communicate with external workers. You can delete the code block below (until else)
        if MULTIWORKER: 
            self.peer_port = worker.peer_port    
            assert self.peer_port, "This service requires peers to function!"

            # let agent who holds the service-exe (and worker) know that it has received a request by signaling on the got_req_q
            self.got_req_q.put('ADD')

            # Populate the peer-port's state-space (what this worker is willing to share with other *approved* workers)
            # self.peer_port.state_space["state"] = None        # FIXME: Do this for all states this worker is willing to share
            
            # Connect peer-port to all the peers -- Note that the worker possesses the PeerPort object
            self.peer_port.tie_to_peers()
            time.sleep(self.BIND_WAIT)

            self.worker_leader_bool = True       # FIXME: is this particular worker the leader? Can also pass this through the inputs
            self.multi_main_loop(request=request)

        else: 
            self.single_main_loop(request=request)


    def single_main_loop(self, request=request):
        """
        The main loop wherein a single worker works on something and returns single result 
        """

        raise NotImplementedError       # FIXME: Delete this line

        ################# START: SINGLE WORKER ##################
        time.sleep(0.5)        # FIXME: Reduce time or delete
        payload = None         # FIXME: compute some result (payload) using inputs and self to return to the client 
        reply = {'payload': payload, 'origin': self.worker_name}
        return reply 
        ################# END: SINGLE WORKER ##################
    

    def multi_main_loop(self, request=None): 
        """
        The main loop wherein requests are made to other agents and where the processing happens
        """

        raise NotImplementedError       # FIXME: Delete this line 
        
        ################# START: MULTIPLE WORKERS + LEADER ##################
        # If this is the leader, or the worker that initiates/prompts things, can differentiate between agent types
        if self.worker.leader_bool: 

            # FIXME: Solicit your peers for something -- see request_from_peers method inside service_exe (write code here)
            # FIXME: Perform computation on the states of peers (write code here)
            
            # If this is meant to run forever (unless forcibly quit) uncomment below
            """
            while True: 
                try: 
                    # FIXME: Do something continuously (write code here)
                    pass 
                except KeyboardInterrupt:
                    break 
            """
            # Otherwise, return result once and die . . . uncomment below 
            """
            time.sleep(0.5)     # FIXME: Reduce time for waiting or delete
            
            payload = None      # FIXME: compute some result (payload) using inputs and self to return to the client (write code here)
            reply = {'payload': payload, 'origin': self.worker_name}        # FIXME: Construct the reply with payload 
            return reply 
            """

        else:       # Otherwise (not the leader/initiator) 
            other_peer_data = self.peer_port.state_space['other_peer_data']
            while not other_peer_data: 
                time.sleep(0.1)

            # FIXME: Process other_peer_data (write code here)
            
            # If this is meant to run forever (unless forcibly quit) uncomment below
            """
            while True: 
                try: 
                    # FIXME: Do something continuously (write code here)
                    pass 
                except KeyboardInterrupt: 
                    break 
            """
            # Otherwise, return result once and die . . .
            """
            time.sleep(0.5)     # FIXME: Reduce time for waiting or delete 

            payload = None      # FIXME: compute some result (payload) using inputs and self to return to the client (write code here)
            reply = {'payload': payload, 'origin': self.worker_name}         # FIXME: Construct the reply with payload 
            return reply 
            """
        ################# END: MULTIPLE WORKERS + LEADER ##################